# platform-csharp-common

A shared library for Rumble platform service development.

# Introduction

This library has a single purpose: make service development less painful.  By inheriting from the classes in this project, we can better enforce standards for code quality, inputs and outputs, and more rapidly get new services up and running.

Since this library is used with every C# platform project, be very mindful when making potentially breaking changes.  Especially since it's a young project, this will be unavoidable, but make sure any changes are communicated clearly to respective project owners.

# Glossary

| Term | Definition |
| :--- | :--- |
| Client | The application that consumes a web service.  This could be a phone app / game, an internal website like the publishing app, or even a tool like Postman. |
| Controller | A static class that handles API routing for requests.  Controllers contain most of the logic for requests and send data back to the client. |
| JWT / Token | A JSON Web Token.  This is an encrypted token issued by one of our servers.  It can be decrypted to guarantee clients are who they say they are, as well as contain relevant permissions. |
| Model | A representation of a data object.  If the model represents a MongoDB object, it should have both database and friendly keys for JSON serialization. Models should only contain logic that is relevant to the object they represent. |
| Request | The incoming message from the client that's asking the service to do something.  Requests should always be JSON. |
| Response | The outgoing message to the client containing relevant data.  Responses should always be JSON. |
| Response Object | A JSON-serialized object.  The standard for platform is to use the class name as the field name in a JSON response, e.g. `"foo": { /* foo object data */ }`. |
| Route | The relative URL path a client uses to access the API.  Example: `/chat/messages/send` |
| Service | A static class acting as an interface between a Controller and a data layer such as MongoDB. For Mongo specifically, every collection should have a corresponding Service. |

# Adding The Library

1. Create a personal access token (PAT) on gitlab: https://gitlab.cdrentertainment.com/-/profile/personal_access_tokens
2. In Rider, open the NuGet window (`View` > `Tool Windows` > `NuGet`).
3. In the NuGet window, open the `Sources` tab.
4. Add a new feed:
	1. URL: `https://gitlab.cdrentertainment.com/api/v4/projects/14/packages/nuget/index.json`
	2. Username: Your gitlab username, e.g. `william.maynard`
	3. Password: Your PAT from Step 1.
5. Right-click on the project you want to add the library to.
6. Click `Manage NuGet Packages`.
7. Search for `platform-csharp-common`.  If everything is configured correctly, you should see the current version with `gitlab` as the source.
8. Select it, then click the `+` button in the right panel to add the library to the project.

Gitlab official documentation: https://docs.gitlab.com/ee/user/packages/nuget_repository/

# Core Concepts

### Secured by JWT

All endpoints that affect any of our data should be secured by a JSON Web Token (JWT).  JWTs can be encoded with data to indicate permissions and relevant user information.  For security reasons, all information that is used to uniquely identify users should be embedded in the JWT, not accepted from a request body.

Currently, JWTs are generated by `player-service` and decoded via a web request `/player/verify`.

### Everything JSON

Every endpoint should accept a JSON body (unless it's a GET request) and return a JSON body.  No exceptions; consistency and maintainability is important.

### Built on Models, Controllers, and Services

All Platform microservices should be built around MVC methodologies.  Particularly for MongoDB services:

* **Models** should store all of your data, and can be used to serialize to and from JSON data.  Every property should contain two attributes:
	* `[BsonElement(DB_KEY_{NAME})]`: An abbreviated key for the field.  For example, "timestamp" could be shortened to "ts".  Given the potential scale of millions of players, any and all savings can be significant.
	* `[JsonProperty(PropertyName = FRIENDLY_KEY_{NAME})]`: A human-readable key.  This is what gets sent out in responses, and is what frontend devs will use.
* **Services** are interfaces between your project and the MongoDB databases.  Every time you need to access a new Mongo Collection, you should have a corresponding Service to go with it, and vice versa.  Services are essentially static classes with an open connection Mongo and should handle all of the I/O operations for it.
* **Controllers** handle all the routing and for API requests.  Use controllers to validate data, manipulate it, and issue requests to your services.

### Standardized Responses

When sending data to clients, any models should be contained in an appropriately named **response object**.  If the endpoint is supposed to return an array of `Foo` objects and a `Bar` object, the response data should look like:

	{
	  "success": true,
	  "foos": [
	    { /* foo1 */ },
	    { /* foo2 */ }
	  ],
	  "bar": {
	    /* data for a Bar */
	  }
	}

Objects should never mix their data, and should be contained in their own key.  Previous Platform projects written in Groovy tended to be flat, returning unrelated data together at the top level of the response JSON.  Organization adds a little more overhead in payload, but makes the code much easier to maintain and work with, especially when working on model-focused design.

### Magic Through Filters

This library uses several filters in the creation of APIs.  The filters contain methods that execute both before and after an endpoint does its work.  Token authorization, exceptions, and performance metrics are among the powerful tools included in every API.

### Detailed Exceptions

If you need to throw an Exception, consider making a custom Exception class that inherits from `RumbleException`.  All RumbleExceptions should have relevant data properties.  Any uncaught RumbleException that hits the filter mentioned above will be serialized into JSON and sent to Loggly, so the more data you include in the class, the easier it will be to diagnose issues.

### Accountability in Logs

Every entry in Loggly has an `owner`.  While the problem may not be that person's fault, they are the point of first contact should something go wrong, as they'll have a good understanding of what could have gone wrong.  The owner should generally be whoever wrote the call to send data to Loggly.

### Hardened Responses

Avoid sending any data to clients when they don't need it.  Failed responses should contain minimalistic responses with a vague message.  We don't want malicious actors hitting our API and receiving detailed information that can help them.  Internal users diagnosing their problems can always use Loggly data to troubleshoot, after all.

However, if you have an environment variable for `RUMBLE_DEPLOYMENT` that contains the text "local", failed responses will contain the same details Loggly gets.

### Use Environment Variables & Dynamic Config

It doesn't make sense to hard-code configuration values into projects.  URLs can change, and values might need to be swapped around on the fly, and occasionally you'll want different environments to behave slightly differently, like getting more diagnostics when working locally.

Dynamic Config is something Platform will need to re-evaluate and address in the near future, so more information will be available soon on that.

When working locally, always add an `environment.json` file to your project's base directory, then add the file to your `.gitignore`.  You may need to right click the file within Rider and set the `Build Action` to `Content` in order for it to be copied to the `bin` directory.

### Documentation, Documentation, Documentation

Documentation is a chore, but maintaining projects is far less painful when it's done right.  It's natural for documentation to fall behind or get pushed into a backlog.  Whenever it's time to step away from a project for a while, make sure you've left an updated README and comments in your code.  Even if it's a project that no one else will be touching, having notes handy will reduce the time it takes to resume work on a project for future iterations or maintenance.

Write with the assumption that your reader has no knowledge of the topic.  Important factors to consider:

1. Are there any identifiable inefficiencies anywhere?
2. Were there features you wanted to add, but didn't get around to?
3. Were there any kluges you had to add?
4. How would someone else consume the service / project?
5. How would someone get set up to run the service / project on their local machine?
6. Any important notes to someone who has to maintain the project in your absence?

# Class Overview

## Exceptions

| Name | Description |
| :--- | :--- |
| `FailedRequestException` | Raised when a Web Request fails.  Tracks the endpoint and data used for the request. |
| `FieldNotProvidedException` | Raised when JSON bodies are missing expected values. Contains the missing field's name as a property. |
| `InvalidTokenException` | Raised when the token passed in the Authorization header fails validation. |
| `PlatformException` | The abstract base class for all custom Exceptions.  Contains an `Endpoint` property, which uses the stack trace to look up the routing for the endpoint that raised it. |
| `PlatformMongoException` | A klugey wrapper for MongoCommandExceptions.  MongoExceptions don't like being serialized to JSON, so it's a workaround for them. |
| `PlatformSerializationException` | A kind of catch-all Exception to use when JSON serialization fails. |

## Filters

| Name | Description |
| :--- | :--- |
| `PlatformAuthorizationFilter` | This filter looks for `RequireAuth` and `NoAuth` attributes on methods and classes.  When it finds these attributes, it attempts to verify request's authorization token against the `RUMBLE_TOKEN_VERIFICATION` environment variable.  Token information can then be used by Controllers via the `Token` property. |
| `PlatformBodyReaderFilter` | A request's body can only be read once without painful workarounds.  Microsoft's tutorial suggests using attributes within parameter declarations, but this filter instead reads all request bodies before the request even gets there.  It can then be accessed by Controllers via the `Body` property any number of times. |
| `PlatformExceptionFilter` | This filter is responsible for catching all Exceptions within a project's endpoints.  It standardizes logs and responses to the client. |
| `PlatformPerformanceFilter` | This filter monitors performance metrics and occasionally generates Loggly reports.  When grafana integration is added, it will also be implemented in this filter. |

## Interop

| Name | Description |
| :--- | :--- |
| `LogglyClient` | A simple wrapper for Loggly integration, solely used to POST logs. |
| `SlackAttachment` | A model representing an `Attachment` for Slack's API.  Attachments are messages with text set to the right of a colored bar. |
| `SlackBlock` | A model representing a `Block` for Slack's API.  This is the standard for a message body. |
| `SlackFormatter` | Utility class to help format data for Slack. |
| `SlackMessage` | A model representing a `Message` for Slack's API.  A message consists of one or more blocks or attachments. |
| `SlackMessageClient` | A helper class to send messages to Slack.  Accepts a channel ID and API token (issued by Slack) in its constructor so that multiple channels and multiple Slack apps can be supported. |

### Slack Integration | "Hello, World!" Example

Functionality with Slack is easy with the interop classes.  This section assumes that you have created a Slack channel and a Slack app before continuing.

```
string channel = "ABCDEFGHI"; // your Slack channel's ID
string token = "xoxb-deadbeefdeadbeefdeadbeef"; // your Slack app's token, issued from Slack

SlackMessageClient slack = new SlackMessageClient(channel, token);

List<SlackBlock> content = new List<SlackBlock>()
{
    new SlackBlock("Hello, World!")
};
SlackMessage message = new SlackMessage(content);
slack.Send(message);
```

A `SlackMessage` may also contain attachments, each of which containing its own List of SlackBlocks.  Note that there are some limitations to Slack's API; each block must be less than a certain length and a message has a maximum limit on the number of blocks and attachments it can contain.  The interop classes handle some of these issues, but will need to be touched up to split messages when these limits are exceeded.

Helpful resources for working with Slack:
* [Slack Apps Page](https://api.slack.com/apps)
* [Block Kit Builder](https://slack.com/workspace-signin?redir=%2Fapi%2F%2Ftools%2Fblock-kit-builder)


## Utilities

| Name | Description |
| :--- | :--- |
| `Async` | A helper utility to make Asynchronous programming in C# a little less painful.  It's still a little barebones, but is good for fire-and-forget tasks like interfacing with external APIs. |
| `Diagnostics` | If you need something done using reflection or the stack trace, Diagnostics is the tool to use. |
| `JsonHelper` | A wrapper for Newtonsoft's `ToObject<T>()` among other helper methods. |
| `Log` | Contains methods for each event severity level.  In ascending order, they are: VERBOSE, LOCAL, INFO, WARNING, ERROR, CRITICAL.  Only events of INFO severity or above are sent to Loggly; others are printed out to the console window. |
| `NoAuth` | Attribute valid on methods only.  Can be used to bypass class-level `RequireAuth` attributes. |
| `Owner` | An enum of Rumble employees who can own log events.  This will almost exclusively be reserved for Platform engineers in projects here, though. |
| `PlatformEnvironment` | A class used to grab environment variables via the method `Variable(string)`. |
| `RequireAuth` | Attribute valid on classes or methods.  Indicates that the Controller or individual endpoint needs to have a valid token.  May use a `TokenType` as a parameter; defaults to `TokenType.STANDARD`. |
| `TokenType` | Enum for which type of token to use. |
| `WebRequest` | A wrapper for RestSharp web requests. |

## Web

| Name | Description |
| :--- | :--- |
| `ErrorResponse` | Whenever a request encounters an Exception, the `PlatformExceptionFilter` class sends one of these out.  They contain debug data in local environments. |
| `PlatformCollectionDocument` | An abstract subclass of `PlatformDataModel`; this adds a `BsonId` and is intended for MongoDB collection-level models.  More features may be added later. |
| `PlatformDataModel` | An abstract class that contains helpful methods for all models, such as `JSON` and `ResponseObject` properties. |
| `PlatformStartup` | Adds a layer of abstraction for every Service.  Make your Startup class inherit from this to automatically add the `PlatformExceptionFilter` and `PlatformPerformanceFilter`. |
| `RumbleController` | An abstract class that all Platform controllers should inherit from.  Contains standard methods for validating JWTs and creating response objects. |
| `RumbleMongoService` | An abstract class that all services that connect to MongoDB should inherit from. |
| `StandardResponse` | Deprecated. |
| `TokenInfo` | A model that contains all identifiable information for a given token. |

# Getting Started

1. Create a directory in your development folder for the Platform .NET projects.
2. Clone all Platform projects you plan on working on to this directory, including `platform-csharp-common`.
3. Open Rider.  Create an empty solution named `Platform` in the same directory.
4. In the Solution window, right click on `Platform` > `Add` >  `Add Existing Project...`.
5. Add the cloned projects to the solution.

Your directory structure should look like:

* `{PROJECT_FOLDER}`
	* `{PROJECT 1}`
	* `{PROJECT 2}`
	* `platform-csharp-common`
	* `Platform.sln`

If you haven't done so yet, you will need to add gitlab to your NuGet sources.  See the above section `Adding the Library` for more details on how to do this.

# Future Updates, Optimizations, and Nice-to-Haves

* The Async class needs a few updates to be more helpful.
	* [Will] I pulled most of the class from a personal project I worked on years ago, but in that time .NET has deprecated `Thread.Abort()` and as a result, Async doesn't currently have a way of forcefully stopping a thread.
* .NET has better support for JWTs than making a web request to a service.  This should shave off valuable time from our responses.
* SlackMessages need to be split into multiple messages if limits are exceeded.  Similarly, rate-limiting may be an issue later down the line.

# Troubleshooting

#### *I suspect there's a problem in the platform-csharp-common code and want to debug it, or I want to test changes to platform-csharp-common without pushing.*

You can remove the NuGet package from each project and directly reference `platform-csharp-common` as a project dependency.  Be warned, though, that if your project is using a previous version of the project that you will need to revert it to the appropriate state to get accurate results.

#### *I made changes to `platform-csharp-common` and pushed a new version up, but I don't see an option to upgrade in Rider's NuGet package manager.*

If you're sure the gitlab build process has completed, there's a refresh button off to the left side of Rider's NuGet panel.  Sometimes Rider needs a little kick to look for the updated package.